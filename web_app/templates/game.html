<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Model with Capsule Physics and Rotation Offset</title>
  <link rel="icon" href="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=">
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    .dg.ac {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

</head>
<body>

  <script src="/static/js/ammo/ammo.wasm.js"></script>

  <script type="module">
    import * as THREE from '/static/js/three/three.module.js';
    import { OrbitControls } from '/static/js/three/OrbitControls.js';
    import { MTLLoader } from '/static/js/three/MTLLoader.js';
    import { OBJLoader } from '/static/js/three/OBJLoader.js';
    















    const settings = {
      showDebugArrows: true,
      showColliderMeshes: false,
    };

    let showDebugArrowsController;

    const sensorDisplay = {
      distance: '...',
      object: '...'
    };

    let instructionsBox;
    let instructionsBoxContent;
    let instructionsBoxButton;

    const GRAVITY = -9.81;

    let scene, camera, renderer, controls;
    let physicsWorld, tmpTransform;
    let robot = null;
    let robotVisual = null;
    const rigidBodies = [];
    const gameObjects = [];
    const keys = {};
    const clock = new THREE.Clock();

    const PLANE_SIZE = 500;

    const ROBOT_MODEL_SCALE = new THREE.Vector3(0.05, 0.05, 0.05);
    const ROBOT_MODEL_OFFSET = new THREE.Vector3(0.3, -3.5, 0);
    const ROBOT_MODEL_ROTATION = new THREE.Euler(-Math.PI/2, 0, 0);
    const ROBOT_RADIUS = 2;
    const ROBOT_HEIGHT = 7;
    const ROBOT_MASS = 1;
    const ROBOT_IMPULSE_STRENGTH = 0.8;
    const ROBOT_IMPULSE_CLIMB_STRENGTH = 0.1;
    const ROBOT_ROTATION_SPEED = 0.05;
    const ROBOT_BASE_FRICTION = 6.0;
    const ROBOT_LATERAL_FRICTION = 1000.0;
    const ROBOT_USE_ANISOTROPIC_FRICTION = true;
    let ROBOT_GRABBING = false;
    const JUMP_STRENGTH = 20;
    const GROUND_THRESHOLD = 0.1;


    const CAMERA_MIN_DISTANCE = 30;
    const CAMERA_MAX_DISTANCE = 60;
    const CAMERA_ADJUST_SPEED = 0.05;
    const CAMERA_VERTICAL_OFFSET = 20;  // how high above the robot we want to stay
    const CAMERA_VERTICAL_ADJUST_SPEED = 0.05; // how fast it moves toward that height
    let cameraAutoFollowEnabled = true;

    let framesSinceStart = 0;

    const multi_frame_events = {};

    let timelineRobot = []; // stores the action schedule
    let timelineActiveRobot = true;
    let timelineClockRobot = 0; // tracks how much time has passed since start()

    let timelineEvent = []; // stores the action schedule
    let timelineActiveEvent = true;
    let timelineClockEvent = 0; // tracks how much time has passed since start()

    let distanceController;
    let objectController;

    let armBody;
    let armHinge;

    let handMesh = null;
    let handBody = null;
    let handPosition = new THREE.Vector3(); // updated each frame

    let deltaTime;
    let now;






















      













      function start() {

        // YOUR CODE HERE

        // scheduleRobotSequence(1, [
        //   { action: doNothing, duration: 1, maxExecutions: 1},
        //   { action: moveRobotForward, conditionFunction: reachedBuddy},
        //   { action: armGrab, duration: 0.5},
        //   { action: armUp, duration: 0.5 },
        //   { action: armStop, duration: 0.1 },
        //   { action: turnRobotRight, duration: 0.55 },
        //   { action: moveRobotForward, duration: 2 },
        //   { action: turnRobotRight, duration: 0.55 },
        //   { action: moveRobotForward, duration: 2 },
        //   { action: turnRobotRight, duration: 0.55 },
        //   { action: moveRobotForward, duration: 1.8 },
        //   { action: turnRobotRight, duration: 0.45 },
        //   { action: armDown, duration: 0.2 },
        //   { action: armDrop, duration: 0.5 },
        //   { action: armStop, duration: 0.1 },
        // ]);
      }








    function update() {
      coreGame();

      // YOUR CODE HERE

      cameraAutoFollowEnabled = true;

      if(distanceSensor(0) < 30) // obstacle detected directly ahead within 30 steps
      {
        turnRobotRight();
        moveRobotBackward();
      }
      else if (distanceSensor(Math.PI/6) < 25) // obstacle detected on left at 30 degrees within 25 steps
      {
        turnRobotRight();
      }
      else if (distanceSensor(-Math.PI/6) < 25) // obstacle detected on right at 30 degrees within 25 steps
      {
        turnRobotLeft();
      }
      else
      {
        moveRobotForward();
      }

    }












    function reachedBuddy()
    {
      return detectObject() === "robot_buddy" && distanceSensor() < 10;
    }







    function spawnGameObjects(){

      createCapsuleRobot(ROBOT_RADIUS, ROBOT_HEIGHT, ROBOT_MASS, new THREE.Vector3(0, 0, 50), "robot");

      createStaticGroundCollider();

      armBody = createRobotArm();
      armHinge = attachArmToRobot(armBody);

      createBoxDynamic(
        new THREE.Vector3(40, 0, 25),
        new THREE.Vector3(5, 6, 5),
        0.01,
        {
          objPath: '/static/models/gold/tinker.obj',
          mtlPath: '/static/models/gold/obj.mtl',
          scale: new THREE.Vector3(0.12, 0.12, 0.22),
          rotation: new THREE.Euler(-Math.PI/2, 0, 0),
          offset: new THREE.Vector3(0, -3, 0.5)
        },
        "gold1"
      );

      createBoxDynamic(
        new THREE.Vector3(-40, 0, 25),
        new THREE.Vector3(5, 6, 5),
        0.01,
        {
          objPath: '/static/models/gold/tinker.obj',
          mtlPath: '/static/models/gold/obj.mtl',
          scale: new THREE.Vector3(0.12, 0.12, 0.22),
          rotation: new THREE.Euler(-Math.PI/2, 0, 0),
          offset: new THREE.Vector3(0, -3, 0.5)
        },
        "gold2"
      );

      createBoxObstacle(
        new THREE.Vector3(0, 0, 30),
        new THREE.Vector3(15, 17, 15),
        0,
        {
          objPath: '/static/models/lander/tinker.obj',
          mtlPath: '/static/models/lander/obj.mtl',
          scale: new THREE.Vector3(0.6, 0.6, 0.6),
          rotation: new THREE.Euler(Math.PI / 2, Math.PI, Math.PI),
          offset: new THREE.Vector3(0, 0, 5)
        },
        "lander"
      );

      createCapsuleObstacle(
        new THREE.Vector3(0, -55, 150),
        30,
        60,
        0,
        {
          objPath: '/static/models/rock/tinker.obj',
          mtlPath: '/static/models/rock/obj.mtl',
          scale: new THREE.Vector3(0.9, 0.9, 0.9),
          rotation: new THREE.Euler(0, Math.PI / 2, Math.PI / 2),
          offset: new THREE.Vector3(-30, 28, -4)
        },
        "rock1"
      );

      createCapsuleObstacle(
        new THREE.Vector3(0, -30, -150),
        30,
        60,
        0,
        {
          objPath: '/static/models/rock/tinker.obj',
          mtlPath: '/static/models/rock/obj.mtl',
          scale: new THREE.Vector3(0.9, 0.9, 0.9),
          rotation: new THREE.Euler(0, Math.PI / 2, Math.PI / 2),
          offset: new THREE.Vector3(-30, 28, -4)
        },
        "rock2"
      );

      createCapsuleObstacle(
        new THREE.Vector3(150, -30, 0),
        30,
        60,
        0,
        {
          objPath: '/static/models/rock/tinker.obj',
          mtlPath: '/static/models/rock/obj.mtl',
          scale: new THREE.Vector3(0.9, 0.9, 0.9),
          rotation: new THREE.Euler(0, Math.PI / 2, Math.PI / 2),
          offset: new THREE.Vector3(-30, 28, -4)
        },
        "rock3"
      );

      createCapsuleObstacle(
        new THREE.Vector3(-150, -30, 0),
        30,
        60,
        0,
        {
          objPath: '/static/models/rock/tinker.obj',
          mtlPath: '/static/models/rock/obj.mtl',
          scale: new THREE.Vector3(0.9, 0.9, 0.9),
          rotation: new THREE.Euler(0, Math.PI / 2, Math.PI / 2),
          offset: new THREE.Vector3(-30, 28, -4)
        },
        "rock4"
      );


      createCapsuleDynamic(
        new THREE.Vector3(0, 20, 90),
        2, // radius
        7, // height
        0.001, // mass
        {
          objPath: '/static/models/robot/tinker.obj',
          mtlPath: '/static/models/robot/obj.mtl',
          scale: new THREE.Vector3(0.05, 0.05, 0.05),
          rotation: new THREE.Euler(-Math.PI/2, 0, 0),
          offset: new THREE.Vector3(0.3, -3.5, 0)
        },
        "robot_buddy"
      );






      // create rocks around edge of plate to make boundary
      let rockCounter = 1;
      const rockSpacing = 50;
      const rockRadius = 30;
      const rockHeight = 60;
      const rockY = -30;

      const rockOptions = {
        objPath: '/static/models/rock/tinker.obj',
        mtlPath: '/static/models/rock/obj.mtl',
        scale: new THREE.Vector3(0.9, 0.9, 0.9),
        rotation: new THREE.Euler(0, Math.PI / 2, Math.PI / 2),
        offset: new THREE.Vector3(-30, 28, -4)
      };

      // Top edge (z = PLANE_SIZE/2)
      for (let x = -PLANE_SIZE/2; x <= PLANE_SIZE/2; x += rockSpacing) {
        createCapsuleObstacle(new THREE.Vector3(x, rockY, PLANE_SIZE/2), rockRadius, rockHeight, 0, rockOptions, `rock${rockCounter++}`);
      }

      // Bottom edge (z = -PLANE_SIZE/2)
      for (let x = -PLANE_SIZE/2; x <= PLANE_SIZE/2; x += rockSpacing) {
        createCapsuleObstacle(new THREE.Vector3(x, rockY, -PLANE_SIZE/2), rockRadius, rockHeight, 0, rockOptions, `rock${rockCounter++}`);
      }

      // Right edge (x = PLANE_SIZE/2)
      for (let z = -PLANE_SIZE/2 + rockSpacing; z < PLANE_SIZE/2; z += rockSpacing) {
        createCapsuleObstacle(new THREE.Vector3(PLANE_SIZE/2, rockY, z), rockRadius, rockHeight, 0, rockOptions, `rock${rockCounter++}`);
      }

      // Left edge (x = -PLANE_SIZE/2)
      for (let z = -PLANE_SIZE/2 + rockSpacing; z < PLANE_SIZE/2; z += rockSpacing) {
        createCapsuleObstacle(new THREE.Vector3(-PLANE_SIZE/2, rockY, z), rockRadius, rockHeight, 0, rockOptions, `rock${rockCounter++}`);
      }









    }



















    function keyBoardListener(){

      window.addEventListener('keydown', (e) => {
        keys[e.key] = true;

        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
          cameraAutoFollowEnabled = true;
        }
      });
      window.addEventListener('keyup', (e) => keys[e.key] = false);
      window.addEventListener('resize', onWindowResize);


      window.addEventListener('keydown', (e) => {
        keys[e.key] = true;

        if (e.key === 's') {
          raiseArm(1.5);
          unfreezeArm()
        }
        if (e.key === 'w') {
          lowerArm(1.5);
          unfreezeArm()
        }
        if(e.key === 'e'){
          ROBOT_GRABBING = true;
        }
        if(e.key === 'r'){
          ROBOT_GRABBING = false;
        }
        if (e.key === ' ' && isGrounded()) {
          robotJump()
        }
      });

      window.addEventListener('keyup', (e) => {
        keys[e.key] = false;

        if (e.key === 'w' || e.key === 's') {
          stopArm(); // stop arm when raise/lower keys are released
          freezeArm()
        }
      });
    }















    async function init() {
      await Ammo();
      tmpTransform = new Ammo.btTransform();

      const gui = new dat.GUI();
      gui.close();

      gui.domElement.addEventListener('keydown', (e) => e.stopPropagation());

      showDebugArrowsController = gui.add(settings, 'showDebugArrows').name('Show Direction Arrows').onChange(() => {
        for (const obj of gameObjects) {
          if (obj.arrows) {
            obj.arrows.x.visible = settings.showDebugArrows;
            obj.arrows.y.visible = settings.showDebugArrows;
            obj.arrows.z.visible = settings.showDebugArrows;
          }
        }
      });


      gui.add(settings, 'showColliderMeshes').name('Show Collider Meshes').onChange(() => {
        for (const obj of gameObjects) {
          if (obj.mesh && obj.name !== "robot_arm") {
            obj.mesh.visible = settings.showColliderMeshes;
          }
        }
      });

      const sensorFolder = gui.addFolder('Robot Sensors');
      distanceController = sensorFolder.add(sensorDisplay, 'distance').name('Distance');
      objectController = sensorFolder.add(sensorDisplay, 'object').name('Object Detected');

      initThree();
      initPhysics();
      createPlane();
      createLighting();
      createInstructionsBox();

      spawnGameObjects();

      keyBoardListener();

      update();
    }





























































    function robotJump(){
      robot.applyCentralImpulse(new Ammo.btVector3(0, JUMP_STRENGTH, 0));
      robot.activate();
    }

    function doNothing()
    {
      let nothing = 0;
      nothing = 0
    }

    function createInstructionsBox() {
      // Create the main container
      instructionsBox = document.createElement('div');
      instructionsBox.id = 'instructions-box';
      document.body.appendChild(instructionsBox);

      // Create the Hide/Show button
      instructionsBoxButton = document.createElement('button');
      instructionsBoxButton.innerText = 'Hide';
      instructionsBoxButton.style.marginBottom = '10px';
      instructionsBoxButton.style.width = '100%';
      instructionsBoxButton.style.padding = '5px';
      instructionsBoxButton.style.cursor = 'pointer';
      instructionsBoxButton.style.border = 'none';
      instructionsBoxButton.style.borderRadius = '5px';
      instructionsBoxButton.style.backgroundColor = '#444';
      instructionsBoxButton.style.color = '#fff';
      instructionsBoxButton.addEventListener('click', toggleInstructionsBox);
      instructionsBox.appendChild(instructionsBoxButton);

      // Create the content container
      instructionsBoxContent = document.createElement('div');
      instructionsBoxContent.innerHTML = `
        <h2>Instructions</h2>
        <p>Use Arrow Keys to move</p>
        <p>Press Space to Jump</p>
        <p>Press S to raise arm, W to lower</p>
        <p>Press E to grab, R to release</p>
        <p>Click 'Open Controls' (top right of screen) to view Colliders and Directional Arrows</p>
        <p>Click 'Robot Sensors' within Controls to view distance and object sensors</p>
      `;
      instructionsBox.appendChild(instructionsBoxContent);

      instructionsBoxContent.style.display = 'none';
      instructionsBoxButton.innerText = 'Show Instructions';

      // Style the box
      instructionsBox.style.position = 'absolute';
      instructionsBox.style.top = '10px';
      instructionsBox.style.left = '10px';
      instructionsBox.style.width = '220px';
      instructionsBox.style.padding = '10px';
      instructionsBox.style.background = 'rgba(20, 20, 20, 0.8)';
      instructionsBox.style.color = '#eee';
      instructionsBox.style.fontFamily = `'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
      instructionsBox.style.fontSize = '13px';
      instructionsBox.style.lineHeight = '1.4';
      instructionsBox.style.borderRadius = '8px';
      instructionsBox.style.boxShadow = '0 2px 8px rgba(0,0,0,0.4)';
      instructionsBox.style.zIndex = '20';
    }


    function toggleInstructionsBox() {
      if (instructionsBoxContent.style.display === 'none') {
        instructionsBoxContent.style.display = 'block';
        instructionsBoxButton.innerText = 'Hide Instructions';
      } else {
        instructionsBoxContent.style.display = 'none';
        instructionsBoxButton.innerText = 'Show Instructions';
      }
    }


    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 55, 100);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      controls.addEventListener('start', () => {
        cameraAutoFollowEnabled = false;
      });
      controls.addEventListener('end', () => {

      });
    }

    function initPhysics() {
      const config = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(config);
      const broadphase = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, config);
      physicsWorld.setGravity(new Ammo.btVector3(0, GRAVITY, 0));
    }

    function createPlane() {
      const loader = new THREE.TextureLoader();
      loader.load('/static/textures/moon.jpg', (texture) => {
        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE),
          new THREE.MeshStandardMaterial({ map: texture })
        );
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
      });
    }


    function createStaticGroundCollider() {
      const halfSize = PLANE_SIZE / 2;

      const shape = new Ammo.btStaticPlaneShape(new Ammo.btVector3(0, 1, 0), 0); 
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(0, 0, 0)); // Y=0
      const motionState = new Ammo.btDefaultMotionState(transform);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, shape, new Ammo.btVector3(0, 0, 0));
      const body = new Ammo.btRigidBody(rbInfo);
      physicsWorld.addRigidBody(body);

      // ðŸ”µ Create the visible collider mesh
      const geometry = new THREE.BoxGeometry(PLANE_SIZE, 2, PLANE_SIZE);
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(0, 1, 0); // Half-height offset (since box is 2 units tall)

      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes; // match setting

      // ðŸ”µ Optional: add to gameObjects for unified visibility management
      gameObjects.push({
        name: "ground_collider",
        body,
        mesh
      });
    }


    function createLighting() {
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);
    }

    function createCapsuleRobot(radius, height, mass, position, name = "player") {
      const shape = new Ammo.btCapsuleShape(radius, height - 2 * radius);
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(position.x, position.y + height / 2, position.z));
      const motionState = new Ammo.btDefaultMotionState(transform);
      const localInertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, localInertia);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      const body = new Ammo.btRigidBody(rbInfo);

      body.setRestitution(0);
      body.setFriction(ROBOT_BASE_FRICTION);
      body.setDamping(0.0, 0.9);
      body.setAngularFactor(new Ammo.btVector3(0, 0, 0));

      if (ROBOT_USE_ANISOTROPIC_FRICTION) {
        const anisotropicFriction = new Ammo.btVector3(ROBOT_LATERAL_FRICTION, 0, 0);
        body.setAnisotropicFriction(anisotropicFriction, Ammo.btCollisionObject.ACF_X);
      }

      physicsWorld.addRigidBody(body);
      rigidBodies.push(body);
      robot = body;

      const geometry = new THREE.CapsuleGeometry(radius, height - 2 * radius, 4, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);

      // if (settings.showColliderMeshes) scene.add(mesh);
      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes;


      const arrows = {
        x: new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), mesh.position, 10, 0xff0000, 3),
        y: new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), mesh.position, 10, 0xffff00, 3),
        z: new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), mesh.position, 10, 0x0000ff, 3)
      };

      if (settings.showDebugArrows) {
        scene.add(arrows.x, arrows.y, arrows.z);
      }

      gameObjects.push({ name, body, mesh, arrows: settings.showDebugArrows ? arrows : null });

      const mtlLoader = new MTLLoader();
      mtlLoader.load('/static/models/robot/obj.mtl', (materials) => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.load('/static/models/robot/tinker.obj', (object) => {
          object.scale.copy(ROBOT_MODEL_SCALE);
          object.rotation.copy(ROBOT_MODEL_ROTATION);
          scene.add(object);
          robotVisual = object;
        });
      });
    }

    function isGrounded(threshold = 2) {
      if (!robot) return false;

      const transform = new Ammo.btTransform();
      robot.getMotionState().getWorldTransform(transform);

      const origin = transform.getOrigin();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());

      // Cast ray straight down from slightly below the robotâ€™s bottom (capsule base)
      const rayStart = new THREE.Vector3(origin.x(), origin.y() - ROBOT_HEIGHT / 2 + ROBOT_RADIUS - 0.1, origin.z());
      const rayEnd = rayStart.clone().add(new THREE.Vector3(0, -threshold, 0)); // cast downward by `threshold`

      const btRayStart = new Ammo.btVector3(rayStart.x, rayStart.y, rayStart.z);
      const btRayEnd = new Ammo.btVector3(rayEnd.x, rayEnd.y, rayEnd.z);
      const rayCallback = new Ammo.ClosestRayResultCallback(btRayStart, btRayEnd);

      physicsWorld.rayTest(btRayStart, btRayEnd, rayCallback);

      if (rayCallback.hasHit()) {
        const hitBody = Ammo.castObject(rayCallback.get_m_collisionObject(), Ammo.btRigidBody);

        // Ignore self or robot arm collisions
        if (hitBody !== robot && hitBody !== robotArmBody) {
          return true;
        }
      }

      return false;
    }

    function moveRobotForward() {
      if (!robot) return;
      const transform = robot.getWorldTransform();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();
      const impulse = new Ammo.btVector3(0, 0, 0);

      const lv = robot.getLinearVelocity();
      const horizSpeed = Math.sqrt(lv.x() * lv.x() + lv.z() * lv.z());
      const climbScale = 1 - Math.min(horizSpeed / 10, 1);
      const climbBoost = ROBOT_IMPULSE_CLIMB_STRENGTH * climbScale;
      impulse.setValue(forward.x * ROBOT_IMPULSE_STRENGTH, climbBoost, forward.z * ROBOT_IMPULSE_STRENGTH);
      robot.activate();
      robot.applyCentralImpulse(impulse);
    }

    function moveRobotBackward() {
      if (!robot) return;
      const transform = robot.getWorldTransform();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();
      const impulse = new Ammo.btVector3(0, 0, 0);

      const lv = robot.getLinearVelocity();
      const horizSpeed = Math.sqrt(lv.x() * lv.x() + lv.z() * lv.z());
      const climbScale = 1 - Math.min(horizSpeed / 10, 1);
      const climbBoost = ROBOT_IMPULSE_CLIMB_STRENGTH * climbScale;
      impulse.setValue(-forward.x * ROBOT_IMPULSE_STRENGTH, climbBoost, -forward.z * ROBOT_IMPULSE_STRENGTH);
      robot.activate();
      robot.applyCentralImpulse(impulse);
    }

    function turnRobotRight() {
      if (!robot) return;
      const transform = robot.getWorldTransform();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();
      const impulse = new Ammo.btVector3(0, 0, 0);

      const delta = -ROBOT_ROTATION_SPEED;
      const axis = new THREE.Vector3(0, 1, 0);
      const dq = new THREE.Quaternion().setFromAxisAngle(axis, delta);
      const rot = transform.getRotation();
      const q = new THREE.Quaternion(rot.x(), rot.y(), rot.z(), rot.w()).multiply(dq);
      transform.setRotation(new Ammo.btQuaternion(q.x, q.y, q.z, q.w));
      robot.setWorldTransform(transform);
      robot.activate();
    }

    function turnRobotLeft() {
      if (!robot) return;
      const transform = robot.getWorldTransform();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();
      const impulse = new Ammo.btVector3(0, 0, 0);

      const delta = ROBOT_ROTATION_SPEED;
      const axis = new THREE.Vector3(0, 1, 0);
      const dq = new THREE.Quaternion().setFromAxisAngle(axis, delta);
      const rot = transform.getRotation();
      const q = new THREE.Quaternion(rot.x(), rot.y(), rot.z(), rot.w()).multiply(dq);
      transform.setRotation(new Ammo.btQuaternion(q.x, q.y, q.z, q.w));
      robot.setWorldTransform(transform);
      robot.activate();
    }

    function moveRobotByInput() {
      if (!robot) return;

      if (keys['ArrowUp'] && isGrounded()) {
        moveRobotForward();
      }

      if (keys['ArrowDown'] && isGrounded()) {
        moveRobotBackward();
      }

      if (keys['ArrowLeft']) {
        turnRobotLeft();
      }

      if (keys['ArrowRight']) {
        turnRobotRight();
      }
    }

    function renderStaticModel(objPath, mtlPath, position, scale, rotation) {
      const mtlLoader = new MTLLoader();
      mtlLoader.load(mtlPath, (materials) => {
        materials.preload();
        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.load(objPath, (object) => {
          object.position.copy(position);
          object.scale.copy(scale);
          object.rotation.copy(rotation);
          scene.add(object);
        });
      });
    }

    function createCapsuleObstacle(position, radius, height, mass = 0, modelOptions = null, name = "CapsuleObstacle") {
      const shape = new Ammo.btCapsuleShape(radius, height - 2 * radius);
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(position.x, position.y + height / 2, position.z));
      const motionState = new Ammo.btDefaultMotionState(transform);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, new Ammo.btVector3(0, 0, 0));
      const body = new Ammo.btRigidBody(rbInfo);
      physicsWorld.addRigidBody(body);

      const geometry = new THREE.CapsuleGeometry(radius, height - 2 * radius, 4, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      // if (settings.showColliderMeshes) scene.add(mesh);
      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes;


      gameObjects.push({ name, body, mesh });


      if (modelOptions && modelOptions.objPath && modelOptions.mtlPath) {
        const offset = modelOptions.offset || new THREE.Vector3(0, 0, 0);
        const modelPos = position.clone().add(offset);

        renderStaticModel(
          modelOptions.objPath,
          modelOptions.mtlPath,
          modelPos,
          modelOptions.scale || new THREE.Vector3(1, 1, 1),
          modelOptions.rotation || new THREE.Euler(0, 0, 0)
        );
      }
    }

    function createBoxObstacle(position, size, mass = 0, modelOptions = null, name = "BoxObstacle") {
      const shape = new Ammo.btBoxShape(new Ammo.btVector3(size.x / 2, size.y / 2, size.z / 2));
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(position.x, position.y + size.y / 2, position.z));
      const motionState = new Ammo.btDefaultMotionState(transform);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, new Ammo.btVector3(0, 0, 0));
      const body = new Ammo.btRigidBody(rbInfo);
      physicsWorld.addRigidBody(body);

      const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
      const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);

      // if (settings.showColliderMeshes) scene.add(mesh);
      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes;

      gameObjects.push({ name, body, mesh });


      if (modelOptions && modelOptions.objPath && modelOptions.mtlPath) {
        const offset = modelOptions.offset || new THREE.Vector3(0, 0, 0);
        const modelPos = position.clone().add(offset);

        renderStaticModel(
          modelOptions.objPath,
          modelOptions.mtlPath,
          modelPos,
          modelOptions.scale || new THREE.Vector3(1, 1, 1),
          modelOptions.rotation || new THREE.Euler(0, 0, 0)
        );
      }
    }

    function createBoxDynamic(position, size, mass = 5, modelOptions = null, name = "BoxDynamic") {
      const shape = new Ammo.btBoxShape(new Ammo.btVector3(size.x / 2, size.y / 2, size.z / 2));
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(position.x, position.y + size.y / 2, position.z));
      const motionState = new Ammo.btDefaultMotionState(transform);
      const localInertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, localInertia);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      const body = new Ammo.btRigidBody(rbInfo);

      body.setRestitution(0.1);
      body.setFriction(1.0);
      body.setRollingFriction(0.3);
      body.setActivationState(Ammo.DISABLE_DEACTIVATION);

      physicsWorld.addRigidBody(body);
      body.activate();
      body.setLinearVelocity(new Ammo.btVector3(0, -1, 0));

      const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      // if (settings.showColliderMeshes) scene.add(mesh);
      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes;


      if (modelOptions && modelOptions.objPath && modelOptions.mtlPath) {
        const offset = modelOptions.offset || new THREE.Vector3(0, 0, 0);
        const scale = modelOptions.scale || new THREE.Vector3(1, 1, 1);
        const rotationEuler = modelOptions.rotation || new THREE.Euler(0, 0, 0);
        const rotationOffsetQuat = new THREE.Quaternion().setFromEuler(rotationEuler);

        const mtlLoader = new MTLLoader();
        mtlLoader.load(modelOptions.mtlPath, (materials) => {
          materials.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.load(modelOptions.objPath, (object) => {
            object.position.copy(position.clone().add(offset));
            object.scale.copy(scale);
            scene.add(object);

            gameObjects.push({
              name,
              body,
              mesh,
              visual: object,
              visualOffset: offset,
              visualRotationOffset: rotationOffsetQuat
            });
          });
        });
      } else {
        gameObjects.push({ name, body, mesh });
      }
    }

    function createCapsuleDynamic(position, radius, height, mass = 5, modelOptions = null, name = "CapsuleDynamic") {
      const shape = new Ammo.btCapsuleShape(radius, height - 2 * radius);
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      transform.setOrigin(new Ammo.btVector3(position.x, position.y + height / 2, position.z));
      const motionState = new Ammo.btDefaultMotionState(transform);
      const localInertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(mass, localInertia);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
      const body = new Ammo.btRigidBody(rbInfo);

      body.setRestitution(0.1);
      body.setFriction(1.0);
      body.setRollingFriction(0.3);
      body.setActivationState(Ammo.DISABLE_DEACTIVATION);

      physicsWorld.addRigidBody(body);
      body.activate();
      body.setLinearVelocity(new Ammo.btVector3(0, -1, 0));

      const geometry = new THREE.CapsuleGeometry(radius, height - 2 * radius, 4, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);

      // if (settings.showColliderMeshes) scene.add(mesh);
      scene.add(mesh);
      mesh.visible = settings.showColliderMeshes;


      if (modelOptions && modelOptions.objPath && modelOptions.mtlPath) {
        const offset = modelOptions.offset || new THREE.Vector3(0, 0, 0);
        const scale = modelOptions.scale || new THREE.Vector3(1, 1, 1);
        const rotationEuler = modelOptions.rotation || new THREE.Euler(0, 0, 0);
        const rotationOffsetQuat = new THREE.Quaternion().setFromEuler(rotationEuler);

        const mtlLoader = new MTLLoader();
        mtlLoader.load(modelOptions.mtlPath, (materials) => {
          materials.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.load(modelOptions.objPath, (object) => {
            object.position.copy(position.clone().add(offset));
            object.scale.copy(scale);
            scene.add(object);

            gameObjects.push({
              name,
              body,
              mesh,
              visual: object,
              visualOffset: offset,
              visualRotationOffset: rotationOffsetQuat
            });
          });
        });
      } else {
        gameObjects.push({ name, body, mesh });
      }
    }

    function updatePhysics(deltaTime) {
      physicsWorld.stepSimulation(deltaTime, 10);

      for (const obj of gameObjects) {
        const { name, body, mesh, arrows, visual, visualOffset, visualRotationOffset } = obj;
        const motionState = body.getMotionState();
        if (motionState) {
          motionState.getWorldTransform(tmpTransform);
          const origin = tmpTransform.getOrigin();
          const rot = tmpTransform.getRotation();

          mesh.position.set(origin.x(), origin.y(), origin.z());
          mesh.quaternion.set(rot.x(), rot.y(), rot.z(), rot.w());

          if (arrows) {
            arrows.x.position.copy(mesh.position);
            arrows.y.position.copy(mesh.position);
            arrows.z.position.copy(mesh.position);
            arrows.x.setDirection(new THREE.Vector3(1, 0, 0).applyQuaternion(mesh.quaternion));
            arrows.y.setDirection(new THREE.Vector3(0, 1, 0).applyQuaternion(mesh.quaternion));
            arrows.z.setDirection(new THREE.Vector3(0, 0, 1).applyQuaternion(mesh.quaternion));
          }

          if (visual) {
            const offsetRotated = visualOffset ? visualOffset.clone().applyQuaternion(mesh.quaternion) : new THREE.Vector3(0, 0, 0);
            visual.position.copy(mesh.position.clone().add(offsetRotated));

            if (visualRotationOffset) {
              const finalQuat = mesh.quaternion.clone().multiply(visualRotationOffset);
              visual.quaternion.copy(finalQuat);
            } else {
              visual.quaternion.copy(mesh.quaternion);
            }
          }

          if (body === robot && robotVisual) {
            const baseQuat = mesh.quaternion;
            const offsetQuat = new THREE.Quaternion().setFromEuler(ROBOT_MODEL_ROTATION);
            const finalQuat = baseQuat.clone().multiply(offsetQuat);

            robotVisual.position.copy(mesh.position).add(ROBOT_MODEL_OFFSET.clone().applyQuaternion(baseQuat));
            robotVisual.quaternion.copy(finalQuat);
          }

          if (obj.name === "robot_arm") {
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(mesh.quaternion);
            const tipOffset = forward.multiplyScalar(4); // distance from center to end
            handPosition.copy(mesh.position.clone().add(tipOffset));
            if (handMesh) handMesh.position.copy(handPosition);
          }

        }
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function getGameObjectByName(name) {
      return gameObjects.find(obj => obj.name === name) || null;
    }

    function addForce(name, power, direction) {
      // Normalize the direction to ensure consistent scaling
      const dir = direction.clone().normalize().multiplyScalar(power);
      for (const obj of gameObjects) {
        if (obj.name === name && obj.body) {
          const force = new Ammo.btVector3(dir.x, dir.y, dir.z);
          obj.body.activate(); // Make sure body is awake
          obj.body.applyCentralImpulse(force); // Use impulse for immediate effect
          break;
        }
      }
    }

    function getDistance(name1, name2) {
      let obj1 = null;
      let obj2 = null;

      for (const obj of gameObjects) {
        if (!obj1 && obj.name === name1) obj1 = obj;
        if (!obj2 && obj.name === name2) obj2 = obj;
        if (obj1 && obj2) break;
      }

      if (!obj1 || !obj2) {
        return null;
      }

      const transform1 = new Ammo.btTransform();
      const transform2 = new Ammo.btTransform();
      obj1.body.getMotionState().getWorldTransform(transform1);
      obj2.body.getMotionState().getWorldTransform(transform2);

      const pos1 = transform1.getOrigin();
      const pos2 = transform2.getOrigin();

      const dx = pos1.x() - pos2.x();
      const dy = pos1.y() - pos2.y();
      const dz = pos1.z() - pos2.z();

      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    function pushAway(name1, name2, power = 2) {
      let obj1 = null;
      let obj2 = null;

      for (const obj of gameObjects) {
        if (!obj1 && obj.name === name1) obj1 = obj;
        if (!obj2 && obj.name === name2) obj2 = obj;
        if (obj1 && obj2) break;
      }

      if (!obj1 || !obj2) {
        return;
      }

      const transform1 = new Ammo.btTransform();
      const transform2 = new Ammo.btTransform();
      obj1.body.getMotionState().getWorldTransform(transform1);
      obj2.body.getMotionState().getWorldTransform(transform2);

      const pos1 = transform1.getOrigin();
      const pos2 = transform2.getOrigin();

      const direction = new THREE.Vector3(
        pos1.x() - pos2.x(),
        pos1.y() - pos2.y(),
        pos1.z() - pos2.z()
      ).normalize();

      const impulse = new Ammo.btVector3(
        direction.x * power,
        direction.y * power,
        direction.z * power
      );

      obj1.body.activate();
      obj1.body.applyCentralImpulse(impulse);
    }

    function startMultiFrameEvent(key, duration, funct) {
      multi_frame_events[key] = {
        timeLeft: duration,
        callback: funct
      };
    }

    function isAnyMultiFrameEventRunning(){
      if (Object.keys(multi_frame_events).length === 0)
      {
          return false;
      }
      else
      {
        return true;
      }
    }

    function isMultiFrameEventRunning(key){
      if (key in multi_frame_events)
      {
          return true;
      }
      else
      {
        return false;
      }
    }

    function updateTimeCounter(deltaTime) {
      for (const key in multi_frame_events) {
        const entry = multi_frame_events[key];
        if (entry.callback) {
          entry.callback(deltaTime); // Run the function for this frame
        }

        entry.timeLeft -= deltaTime;
        if (entry.timeLeft <= 0) {
          delete multi_frame_events[key]; // Remove when time is up
        }
      }
    }

    function scheduleRobotActions(actionsList) {
      timelineRobot = actionsList;
      timelineActiveRobot = true;
      timelineClockRobot = 0;
    }

    function scheduleRobotSequence(startTime, actionsList) {
      timelineRobot = actionsList.map(item => ({
        action: item.action,
        conditionFunction: item.conditionFunction || null,
        duration: item.duration ?? Infinity,
        maxExecutions: item.maxExecutions ?? Infinity,
        executions: 0,
        done: false,
        startTime: null,
        stopTime: null
      }));

      timelineClockRobot = 0;
      timelineActiveRobot = true;
    }

    function runRobotSchedule(deltaTime) {
      if (!timelineActiveRobot) return;

      timelineClockRobot += deltaTime;

      const current = timelineRobot.find(item => !item.done);
      if (!current) {
        timelineActiveRobot = false;
        return;
      }

      if (current.startTime === null) {
        current.startTime = timelineClockRobot;
        current.stopTime = current.conditionFunction
          ? Infinity
          : current.startTime + current.duration;
      }

      const shouldRun = current.executions < current.maxExecutions;
      if (shouldRun) {
        current.action();
        current.executions++;
      }

      const conditionMet = current.conditionFunction && current.conditionFunction();
      const timeExpired = timelineClockRobot >= current.stopTime;

      if (conditionMet || timeExpired) {
        current.done = true;
      }
    }


    function scheduleEventActions(actionsList) {
      timelineEvent = actionsList;
      timelineActiveEvent = true;
      timelineClockEvent = 0;
    }

    function scheduleEventSequence(startTime, actionsList) {
      timelineEvent = actionsList.map(item => ({
        action: item.action,
        conditionFunction: item.conditionFunction || null,
        duration: item.duration ?? Infinity,
        maxExecutions: item.maxExecutions ?? Infinity,
        executions: 0,
        done: false,
        startTime: null,
        stopTime: null
      }));

      timelineClockEvent = 0;
      timelineActiveEvent = true;
    }


    function runEventSchedule(deltaTime) {
      if (!timelineActiveEvent) return;

      timelineClockEvent += deltaTime;

      const current = timelineEvent.find(item => !item.done);
      if (!current) {
        timelineActiveEvent = false;
        return;
      }

      if (current.startTime === null) {
        current.startTime = timelineClockEvent;
        current.stopTime = current.conditionFunction ? Infinity : current.startTime + current.duration;
      }

      const shouldRun = current.executions < current.maxExecutions;
      if (shouldRun) {
        current.action();
        current.executions++;
      }

      const conditionMet = current.conditionFunction && current.conditionFunction();
      const timeExpired = timelineClockEvent >= current.stopTime;

      if (conditionMet || timeExpired) {
        current.done = true;
      }
    }



    function senseRobotDistance(yRotation = 0, maxDistance = 500) {
      if (!robot) return null;

      const rayFrom = new Ammo.btVector3();
      const rayTo = new Ammo.btVector3();

      const transform = new Ammo.btTransform();
      robot.getMotionState().getWorldTransform(transform);

      const origin = transform.getOrigin();
      const rotation = transform.getRotation();
      const baseQuat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());

      // Apply additional y-axis rotation
      const yRotQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yRotation);
      const adjustedQuat = baseQuat.clone().multiply(yRotQuat);

      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(adjustedQuat).normalize();

      // Offset the ray origin forward and slightly above the robot
      const forwardOffset = 3;
      const heightOffset = 2;

      const fromVec = new THREE.Vector3(
        origin.x(), origin.y() + heightOffset, origin.z()
      ).add(forward.clone().multiplyScalar(forwardOffset));

      const toVec = fromVec.clone().add(forward.clone().multiplyScalar(maxDistance));

      rayFrom.setValue(fromVec.x, fromVec.y, fromVec.z);
      rayTo.setValue(toVec.x, toVec.y, toVec.z);

      const rayCallback = new Ammo.ClosestRayResultCallback(rayFrom, rayTo);
      physicsWorld.rayTest(rayFrom, rayTo, rayCallback);

      if (rayCallback.hasHit()) {
        const hitBody = Ammo.castObject(rayCallback.get_m_collisionObject(), Ammo.btRigidBody);
        if (hitBody === robot || hitBody === robotArmBody) return null;

        const hitPoint = rayCallback.get_m_hitPointWorld();
        const dx = hitPoint.x() - origin.x();
        const dy = hitPoint.y() - origin.y();
        const dz = hitPoint.z() - origin.z();

        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }

      return null; // No hit
    }



    function senseRobotHitName(maxDistance = 500, rayStartOffset = 3) {
      if (!robot) return null;

      const rayFrom = new Ammo.btVector3();
      const rayTo = new Ammo.btVector3();

      // Get robot's transform and orientation
      const transform = new Ammo.btTransform();
      robot.getMotionState().getWorldTransform(transform);
      const origin = transform.getOrigin();
      const rotation = transform.getRotation();
      const quat = new THREE.Quaternion(rotation.x(), rotation.y(), rotation.z(), rotation.w());

      // Compute forward direction
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat).normalize();

      // Offset ray start slightly in front of robot to avoid hitting self
      const fromVec = new THREE.Vector3(origin.x(), origin.y(), origin.z()).add(forward.clone().multiplyScalar(rayStartOffset));
      const toVec = fromVec.clone().add(forward.clone().multiplyScalar(maxDistance));

      rayFrom.setValue(fromVec.x, fromVec.y, fromVec.z);
      rayTo.setValue(toVec.x, toVec.y, toVec.z);

      const rayCallback = new Ammo.ClosestRayResultCallback(rayFrom, rayTo);
      physicsWorld.rayTest(rayFrom, rayTo, rayCallback);

      if (rayCallback.hasHit()) {

        const hitBody = Ammo.castObject(rayCallback.get_m_collisionObject(), Ammo.btRigidBody);

        // Ignore hits on robot and arm
        if (hitBody === robot || hitBody === robotArmBody) {
          return null;
        }

        for (const obj of gameObjects) {
          if (obj.body === hitBody) {
            return obj.name;
          }
        }

        return "unnamed";
      }

      return null; // No hit
    }

    function distanceSensor(yRotation = 0, maxDistance = 500)
    {
      const robotDistance = senseRobotDistance(yRotation, maxDistance);
      if (robotDistance !== null) {
        return robotDistance.toFixed(2);
      }
      else
      {
        return 500;
      }
    }

    function detectObject(){
      const name = senseRobotHitName();
      return name;
    }

    function createRobotArm() {
      const armSize = new THREE.Vector3(0.5, 0.5, 8); // width, height, depth
      // const armOffset = new THREE.Vector3(0, 0, ROBOT_RADIUS + 2);
      const armOffset = new THREE.Vector3(0, 0, 0);

      const shape = new Ammo.btBoxShape(new Ammo.btVector3(armSize.x / 2, armSize.y / 2, armSize.z / 2));
      const transform = new Ammo.btTransform();
      transform.setIdentity();

      robot.getMotionState().getWorldTransform(transform);
      const origin = transform.getOrigin();
      const quat = transform.getRotation();
      const baseQuat = new THREE.Quaternion(quat.x(), quat.y(), quat.z(), quat.w());
      const worldOffset = armOffset.clone().applyQuaternion(baseQuat);

      const armPos = new THREE.Vector3(origin.x(), origin.y(), origin.z()).add(worldOffset);
      transform.setOrigin(new Ammo.btVector3(armPos.x, armPos.y, armPos.z));

      const motionState = new Ammo.btDefaultMotionState(transform);
      const localInertia = new Ammo.btVector3(0, 0, 0);
      shape.calculateLocalInertia(0.5, localInertia);

      const rbInfo = new Ammo.btRigidBodyConstructionInfo(0.5, motionState, shape, localInertia);
      const armBody = new Ammo.btRigidBody(rbInfo);
      armBody.setFriction(10.0);           // High base friction
      armBody.setRollingFriction(1.0);     // Optional: reduce rolling/sliding
      armBody.setRestitution(0.1);         // Optional: reduce bounciness
      armBody.setActivationState(Ammo.DISABLE_DEACTIVATION);
      physicsWorld.addRigidBody(armBody);

      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(armSize.x, armSize.y, armSize.z),
        new THREE.MeshStandardMaterial({ color: 0xffaa00 })
      );
      mesh.position.copy(armPos);
      scene.add(mesh);
      gameObjects.push({ name: "robot_arm", body: armBody, mesh });
      window.robotArmBody = armBody;
      window.robotBody = robot;


      // ðŸ”µ Create the hand sphere
      const handRadius = 0.6;
      const handGeom = new THREE.SphereGeometry(handRadius, 16, 16);
      const handMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
      handMesh = new THREE.Mesh(handGeom, handMat);
      scene.add(handMesh);

      // Just visual â€” no physics
      handBody = null;

      return armBody;
    }

    function attachArmToRobot(armBody) {
      // const pivotInRobot = new Ammo.btVector3(0, 0, ROBOT_RADIUS + 1);
      const pivotInRobot = new Ammo.btVector3(0, 0, 0);
      const pivotInArm = new Ammo.btVector3(0, 0, -4); // match arm shape
      // const pivotInArm = new Ammo.btVector3(0, 0, 0); // match arm shape
      const axisInRobot = new Ammo.btVector3(1, 0, 0); // X-axis
      const axisInArm = new Ammo.btVector3(1, 0, 0);

      const hinge = new Ammo.btHingeConstraint(
        robot,
        armBody,
        pivotInRobot,
        pivotInArm,
        axisInRobot,
        axisInArm,
        true
      );

      physicsWorld.addConstraint(hinge, true);
      return hinge;
    }

    function rotateArm(targetAngle = Math.PI / 4, speed = 2.0) {
      if (!armHinge) return;

      armHinge.enableAngularMotor(true, speed, 10);
      armHinge.setLimit(targetAngle, targetAngle, 0.9, 0.3, 1.0); // [lower, upper, softness, bias, relaxation]
    }

    function raiseArm(speed = 1.0) {
      if (!armHinge) return;

      const targetAngle = -Math.PI / 2; // Raise up (towards robot's front)
      const currentAngle = armHinge.getHingeAngle();

      // If we've reached or passed the target angle, stop the motor
      if (currentAngle <= targetAngle) {
        armHinge.enableAngularMotor(false, 0, 0);
        return;
      }

      const direction = -1; // Negative to raise the arm
      const velocity = direction * Math.abs(speed);
      const maxForce = 10;

      armHinge.enableAngularMotor(true, velocity, maxForce);
    }

    function lowerArm(speed = 1.0) {
      if (!armHinge) return;

      const targetAngle = Math.PI / 2; // Allow arm to go lower (downward)
      const currentAngle = armHinge.getHingeAngle();

      // Update hinge limits to allow downward swing
      armHinge.setLimit(-Math.PI / 2, Math.PI / 2, 0.9, 0.3, 1.0);

      if (currentAngle >= targetAngle) {
        armHinge.enableAngularMotor(false, 0, 0);
        return;
      }

      const velocity = Math.abs(speed);
      const maxForce = 10;

      armHinge.enableAngularMotor(true, velocity, maxForce);
    }

    function stopArm() {
      if (!armHinge) return;
      armHinge.enableAngularMotor(false, 0, 0);
    }

    function freezeArm() {
      if (!armHinge) return;

      const currentAngle = armHinge.getHingeAngle();
      armHinge.setLimit(currentAngle, currentAngle, 1.0, 0.3, 1.0); // Lock rotation
      armHinge.enableAngularMotor(false, 0, 0); // Just in case motor was on
    }

    function unfreezeArm() {
      if (!armHinge) return;

      const minAngle = -Math.PI / 2;
      const maxAngle = Math.PI / 2;  // â† Allow full range now
      armHinge.setLimit(minAngle, maxAngle, 0.9, 0.3, 1.0);
    }

    function grab(name, speed = 20) {
      const obj = getGameObjectByName(name);
      if (!obj || !obj.body || !handPosition) return;

      const transform = new Ammo.btTransform();
      obj.body.getMotionState().getWorldTransform(transform);
      const origin = transform.getOrigin();
      const objPos = new THREE.Vector3(origin.x(), origin.y(), origin.z());

      const direction = new THREE.Vector3().subVectors(handPosition, objPos);
      const distance = direction.length();

      if (distance > 0.2) {
        const velocity = direction.normalize().multiplyScalar(speed); // Set a target velocity
        const btVelocity = new Ammo.btVector3(velocity.x, velocity.y, velocity.z);
        obj.body.setLinearVelocity(btVelocity);
      } else {
        // Optional: zero out velocity if it's close enough
        obj.body.setLinearVelocity(new Ammo.btVector3(0, 0, 0));
      }
    }

    function getClosestObjectToHand(maxDistance = 8) {
      if (!handPosition) return null;

      let closest = null;
      let closestDist = Infinity;

      for (const obj of gameObjects) {
        if (!obj.body || obj.name === "robot" || obj.name === "robot_arm") continue;

        const transform = new Ammo.btTransform();
        obj.body.getMotionState().getWorldTransform(transform);
        const origin = transform.getOrigin();
        const objPos = new THREE.Vector3(origin.x(), origin.y(), origin.z());

        const dist = handPosition.distanceTo(objPos);

        if (dist < maxDistance && dist < closestDist) {
          closest = obj;
          closestDist = dist;
        }
      }

      return closest;
    }

    function armGrab(){
      ROBOT_GRABBING=true;
    }

    function armDrop(){
      ROBOT_GRABBING=false;
    }

    function armUp(speed=1){
      raiseArm(speed);
      unfreezeArm()
    }

    function armDown(speed=1){
      lowerArm(speed);
      unfreezeArm()
    }

    function armStop(){
      stopArm();
      freezeArm()
    }

    function coreGame(){
      deltaTime = clock.getDelta();
      now = performance.now() / 1000;
      requestAnimationFrame(update);
      updateTimeCounter(deltaTime);
      if (!timelineActiveRobot){
          moveRobotByInput();
      }

      updatePhysics(deltaTime);

      framesSinceStart++;

      if(framesSinceStart === 1){
        freezeArm();
        settings.showDebugArrows = false;

        // Force update the arrow visibility manually
        for (const obj of gameObjects) {
          if (obj.arrows) {
            obj.arrows.x.visible = settings.showDebugArrows;
            obj.arrows.y.visible = settings.showDebugArrows;
            obj.arrows.z.visible = settings.showDebugArrows;
          }
        }

        if (showDebugArrowsController) {
            showDebugArrowsController.updateDisplay();
          }

        start();
      }

      if(ROBOT_GRABBING){
        const target = getClosestObjectToHand();
        if (target) {
          grab(target.name);
        }
      }



      runRobotSchedule(deltaTime)
      runEventSchedule(deltaTime)

      sensorDisplay.distance = distanceSensor();
      sensorDisplay.object = detectObject() || 'None';
      distanceController.updateDisplay();
      objectController.updateDisplay();


      if (cameraAutoFollowEnabled && robot) {
        const motionState = robot.getMotionState();
        if (motionState) {
          motionState.getWorldTransform(tmpTransform);
          const origin = tmpTransform.getOrigin();
          const targetPos = new THREE.Vector3(origin.x(), origin.y(), origin.z());
          controls.target.lerp(targetPos, 0.1);  // Smooth tracking

          // Gently adjust camera height toward target vertical offset
          const desiredY = controls.target.y + CAMERA_VERTICAL_OFFSET;
          camera.position.y += (desiredY - camera.position.y) * CAMERA_VERTICAL_ADJUST_SPEED;


          const cameraOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
          const currentDistance = cameraOffset.length();

          if (currentDistance > CAMERA_MAX_DISTANCE) {
            camera.position.addScaledVector(cameraOffset.normalize(), -(currentDistance - CAMERA_MAX_DISTANCE) * CAMERA_ADJUST_SPEED);
          } else if (currentDistance < CAMERA_MIN_DISTANCE) {
            camera.position.addScaledVector(cameraOffset.normalize(), (CAMERA_MIN_DISTANCE - currentDistance) * CAMERA_ADJUST_SPEED);
          }
        }
      }
      controls.update();
      renderer.render(scene, camera);
    }



    init();
  </script>
</body>
</html>
